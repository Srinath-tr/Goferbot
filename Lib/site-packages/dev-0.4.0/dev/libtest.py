"""
A straightfoward test framework that minimizes the distance between the test runner, and
the actual tests for the purpose of keeping the execution machinary as simple as possible.

.. warning:: libtest is a work in progress. It is not wise to write custom test runners for dev.libtest at this point.
"""
import sys
import time
import pkgutil
import contextlib
import itertools
from importlib import import_module

def get_test_index(tester : "callable taking the test object"):
	"""
	Returns the first line number of the underlying code object.
	"""
	try:
		return int(tester.__test_order__)
	except AttributeError:
		pass
	# no explicit order index
	if '__wrapped__' in tester.__dict__:
		# Resolve the innermost function.
		visited = set((tester,))
		tester = tester.__wrapped__
		while '__wrapped__' in tester.__dict__:
			visited.add(tester)
			tester = tester.__wrapped__
			if tester in visited:
				# XXX: recursive wrappers? warn?
				return None
	try:
		return int(tester.__code__.co_firstlineno)
	except AttributeError:
		return None

##
# Fate exceptions are used to manage the exception
# and the completion state of a test.
class Fate(Exception):
	name = 'fate'
	message = None
	impact = None
	def __init__(self, message):
		self.message = message
	def __str__(self):
		return self.message

class Pass(Fate):
	'designates that the test passed'
	impact = 1
	name = 'pass'
class Return(Pass):
	impact = 1
	name = 'return'
class Skip(Pass):
	'designates that the test was skipped'
	impact = 0
	name = 'skip'
class Fail(Fate):
	'designates that a test fate condition did not pass'
	impact = -1
	name = 'fail'
class Error(Fail):
	'designates that the test raised an exception'
	name = 'error'
class Expire(Fail):
	'designates that the test did not finish in the allowed time'
	name = 'expire'

def gather(container, prefix = 'test_'):
	'Collect the objects in the container whose name starts with "test\_".'
	for i in container.items():
		if i[0].startswith(prefix):
			yield i

def itermodule(module, **kw):
	'Return the qualified names from `gather(module.__dict__, **kw)`.'
	d = module.__dict__
	cname = module.__name__
	for (name, f) in gather(d, **kw):
		yield ('.'.join((cname, name)), f)

def iterimport(path, *args, **kw):
	'Performs itermodule(import(path)).'
	return itermodule(import_module(path), *args, **kw)

def iterpackage(package_path, *args, **kw):
	pkg = import_module(package_path)
	packages = []
	for (importer, mod, ispkg) in pkgutil.iter_modules(pkg.__path__):
		path = '.'.join((package_path, mod))
		if ispkg:
			packages.append(path)
		else:
			yield path
	# yield the lower depths after the higher ones
	for y in packages:
		for x in iterpackage(y):
			yield x

def itermodules(package_path):
	pkg = import_module(package_path)
	for (importer, name, ispkg) in pkgutil.iter_modules(pkg.__path__):
		path = '.'.join((package_path, name))
		if not ispkg:
			yield path

def iterpackages(package_path):
	'yield the packages in the given package path'
	pkg = import_module(package_path)
	packages = []
	for (importer, name, ispkg) in pkgutil.iter_modules(pkg.__path__):
		path = '.'.join((package_path, name))
		if ispkg:
			yield path

class Trap(object):
	"""
	Context manager used to control exception cases during a test.

	def test_feature(test):
		with test.trap(ValueError):
			int("foobar")
	"""
	def __init__(self, test, *exceptions):
		self.test = test
		self.passes = dict.from_keys(exceptions)

	def __enter__(self):
		return self

	def expect(self, exception):
		'note the exception class that clears the check'
		self.passes[exception] = None

	def __exit__(self, typ, val, tb):
		if typ is None:
			self.test.fail("no exception occurred while was trap set")
		for x in self.passes:
			if isinstance(val, x):
				return True
		self.test.fail("could not trap exception", typ, val, tb)

class Test(object):
	def __init__(self, callable, identity = None):
		# allow explicit identity as the callable may be a wrapped function
		self.entry_point = callable
		self.identity = identity
		self.point = 'initialized'
		self.fate = None
		self.check = None
		self.nchecks = 0
		self.subtests = []

	def run(self):
		try:
			self.checkpoint('running')
			errout = None
			try:
				self.entry_point(self)
				raise Return('test returned')
			except (Exception, KeyboardInterrupt) as err:
				if isinstance(err, Fate):
					raise
				errout = err
			raise Error('test raised exception') from errout
		except Fate as e:
			self.fate = e
		else:
			raise RuntimeError("test run failed to identify fate for the result")
		e = self.fate
		if not isinstance(self.fate, Error):
			e.__traceback__ = e.__traceback__.tb_next
		if e.__cause__:
			e = e.__cause__
			e.__traceback__ = e.__traceback__.tb_next
		for x in self.subtests:
			x.wait()

	def checkpoint(self, msg):
		self.point = str(msg)

	def report(self, message):
		self.log.append(message)

	@contextlib.contextmanager
	def trap(self, x):
		failed = None
		exc = None
		try:
			yield (lambda: exc)
		except Fail:
			# inner failure occured, don't perform check
			failed = False
			raise
		except BaseException as raised_exception:
			if isinstance(raised_exception, x):
				# passed
				failed = False
				exc = raised_exception
				return
			failed = True
			self.fail("exception raised, but was not in the expected list")
		else:
			failed = True
			self.fail("no exception raised for check")

	def skip(self, cause):
		raise Skip(cause)

	def fail(self, cause):
		"""
		Signal that the test failed.
		"""
		raise Fail(cause)

	def fail_if(self, x):
		"""
		Fail if the `x` argument is true. ``bool(x) is True``
		"""
		if x: self.fail("found True object")

	def fail_if_not(self, x):
		"""
		Fail if the `x` argument is false. ``bool(x) is False``
		"""
		if not x: self.fail("found False object")

	def fail_if_hasattr(self, x, y,
		fmt = "found attribute {1} on {0}".format
):
		"""
		Fail if the `x` argument has the `y` argument as an attribute.

		>>> o=object()
		>>> test.fail_if_hasattr(o, 'foo')
		False
		"""
		if hasattr(x, y): self.fail(fmt(x, y))

	def fail_if_not_hasattr(self, x, y,
		fmt = "did not find attribute {1} on {0}".format
):
		"""
		Fail if the `x` argument does *not* have the `y` argument as an attribute.

		>>> o=object()
		>>> test.fail_if_not_hasattr(o, 'foo')
		False
		"""
		if not hasattr(x, y): self.fail("did not have attribute")

	def fail_if_exact(self, x, y):
		"""
		Fail if the `x` argument is exactly the `y` argument. ``x is y``.

		>>> x = b'a unique string'.decode('utf-8')
		>>> y = b'a unique string'.decode('utf-8')
		>>> test.fail_if_exact(x, y)
		False
		"""
		msg = "found exact object"
		if x is y: self.fail(msg)

	def fail_if_not_exact(self, x, y):
		"""
		Fail if the `x` argument is *not* exactly `y` argument. ``x is not y``.

		>>> x = b'a unique string'.decode('utf-8')
		>>> test.fail_if_not_exact(x, x)
		False
		"""
		msg = "found inexact object"
		if x is not y: self.fail(msg)

	def fail_if_equal(self, x, y):
		"""
		Fail if all of the given arguments or keywords are equal.

		>>> test.fail_if_equal(1, 2, 3)
		False
		"""
		msg = "equality"
		if x == y: self.fail(msg)

	def fail_if_not_equal(self, x, y, f = lambda x: x):
		"""
		Fail if the `x` argument is *not* equal to the `y` argument.

		>>> test.fail_if_equal(1, 2)
		False
		"""
		msg = "inequality"
		if f(x) != f(y): self.fail(msg)

	def fail_if_less_than(self, x, y):
		"""
		Fail if the `x` argument is less than the `y` argument.

		>>> test.fail_if_less_than(2, 1)
		False
		"""
		msg = "less than"
		if x < y: self.fail(msg)

	def fail_if_greater_than(self, x, y):
		"""
		Fail if the `x` argument is greater than the `y` argument.

		>>> test.fail_if_greater_than(1, 2)
		False
		"""
		msg = "greater than"
		if x > y: self.fail(msg)

	def fail_if_subclass(self, x, y):
		"""
		Fail if the `x` argument is a subclass of the `y` argument.

		>>> test.fail_if_subclass(ob, typ1, typ2)
		False
		"""
		msg = "subclass"
		if issubclass(x, y): self.fail(msg)

	def fail_if_not_subclass(self, x, y):
		"""
		Fail if the `x` argument is NOT a subclass of the `y` argument.

		>>> test.fail_if_not_subclass(ob, typ1, typ2)
		False
		"""
		msg = "not subclass"
		if not issubclass(x, y): self.fail(msg)

	def fail_if_instance(self, x, y):
		"""
		Fail if the `x` argument is a instance of the `y` class.

		>>> test.isinstance(ob, typ1)
		False
		"""
		msg = "instance"
		if isinstance(x, y): self.fail(msg)

	def fail_if_not_instance(self, x, y):
		"""
		Fail if the `x` argument is not an instance of the `y` class.

		>>> test.fail_if_not_instance(ob, typ1, typ2)
		False
		"""
		msg = "not instance"
		if not isinstance(x, y): self.fail(msg)

	def fail_if_raised(self, x, y, *args, **kw):
		"""
		Fail if the `x` argument is raised by the `y` argument callable.
		"""
		msg = "raised"
		try:
			z = y(*args, **kw)
		except BaseException as z:
			if isinstance(z, x): self.fail(msg)
		else:
			pass

	def fail_if_not_raised(self, x, y, *args, **kw):
		"""
		Fail if the `x` argument is *not* raised by the `y` argument callable.
		"""
		msg = "not raised"
		try:
			z = y(*args, **kw)
		except BaseException as z:
			if not isinstance(z, x): self.fail(msg)
		else:
			self.fail(msg)

	def fail_if_in(self, x, y):
		msg = "contained"
		if x in y: self.fail(msg)

	def fail_if_not_in(self, x, y):
		msg = "not contained"
		if x not in y: self.fail(msg)

	def fail_if_empty(self, x):
		"Fail if the `x` argument is an empty *iterator*"
		msg = "empty"
		for y in x:
			break
		else:
			self.fail(msg)

	def fail_if_not_empty(self, x):
		'validate that the given objects are empty'
		msg = "not empty"
		for y in x: self.fail(msg)
		else:
			# success
			pass

	def fail_if_iterating(self, x):
		"""
		Fail if the `x` argument not at the bottom of the iterator.
		"""
		msg = "iterating"
		try:
			y = next(x); self.fail(msg)
		except StopIteration:
			pass

	def measures(self, consumed = 0, produced = 0):
		'initialize a measurement test'
		self.measuring = unitname
		self.units_in = consumed
		self.units_out = produced

	def xact(self, cunits, punits):
		self.units_in = cunits + self.units_in
		self.units_out = punits + self.units_out

	def timed(self):
		return Timer(self)

	def consumed(self, cunits):
		self.units_in = cunits + self.units_in

	def produced(self, punits):
		self.units_out = punits + self.units_out

def execmodule(module = None):
	"""
	Run the callable modules for programmer test runs (debug on !Pass)'.
	If the module is a package module, run all the contained modules.
	"""
	import pdb, traceback
	import collections
	if module is None:
		module = sys.modules['__main__']
		sys.modules[module.__loader__.fullname] = module
		module.__name__ = module.__loader__.fullname

	if module.__name__ == module.__package__ or module.__package__ + '.__main__' == module.__name__:
		# package module; iterate over the "test" modules.
		import importlib
		modules = [
			importlib.import_module(x)
			for x in itermodules(module.__package__)
			if x.split('.')[-1].startswith('test_')
		]
	else:
		modules = [module]

	for module in modules:
		tests = collections.OrderedDict((
			(id, Test(f, id)) for (id, f) in 
			sorted(gather(module.__dict__), key = lambda kv: get_test_index(kv[1]))
		))
		if len(tests) == 0:
			sys.exit(2)
		failures = False

		args = sys.argv[1:]
		if args:
			test_progress = [tests[k] for k in args]
		else:
			test_progress = tests.values()
		for x in test_progress:
			sys.stderr.write(x.identity + ': ')
			sys.stderr.flush()
			before = time.time()
			x.run()
			duration = time.time() - before
			sys.stderr.write('[' + str(duration) + ' seconds] ')
			sys.stderr.write(x.fate.__class__.__name__ + '\n')
			if not isinstance(x.fate, Pass):
				failures = True
				tb = traceback.format_exception(
					x.fate.__class__, x.fate,
					x.fate.__traceback__
				)
				print(''.join(tb))
				if isinstance(x.fate, Error):
					pdb.post_mortem(x.fate.__cause__.__traceback__)
				else:
					pdb.post_mortem(x.fate.__traceback__)
				break

	if failures is True:
		sys.exit(len(list(test_progress)) + 1)
	sys.exit(0)
